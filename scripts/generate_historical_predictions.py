#!/usr/bin/env python3
"""
Generate historical predictions for past Powerball draws.

This script generates 500 predictions for each draw date from a specified
start date backwards. Useful for populating the database with historical
predictions that can be evaluated against actual results.

Usage:
    python scripts/generate_historical_predictions.py --from-date 2025-11-18 --count 10
"""

import sys
import os
from pathlib import Path

# Add src to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from src.database import get_db_connection
from src.strategy_generators import StrategyManager
from datetime import datetime, timedelta
from loguru import logger
import argparse


def get_historical_draw_dates(from_date: str, count: int) -> list[str]:
    """
    Get the last N Powerball draw dates before the specified date.
    
    Args:
        from_date: Starting date in YYYY-MM-DD format
        count: Number of draw dates to retrieve
        
    Returns:
        List of draw dates in YYYY-MM-DD format, OLDEST FIRST (chronological order)
        
    Note:
        Returns in chronological order (oldest → newest) to ensure adaptive learning
        works correctly. Each evaluation updates strategy weights incrementally,
        simulating real-time learning as if the system had run historically.
    """
    with get_db_connection() as conn:
        cursor = conn.cursor()
        # CRITICAL: ORDER BY ASC (oldest first) for proper adaptive learning progression
        cursor.execute("""
            SELECT draw_date 
            FROM powerball_draws 
            WHERE draw_date <= ?
            ORDER BY draw_date DESC
            LIMIT ?
        """, (from_date, count))
        
        results = cursor.fetchall()
        # Reverse to get chronological order (oldest → newest)
        return [row[0] for row in reversed(results)]


def generate_predictions_for_date(draw_date: str, total_tickets: int = 500) -> int:
    """
    Generate predictions for a specific draw date.
    
    Args:
        draw_date: Draw date in YYYY-MM-DD format
        total_tickets: Number of tickets to generate
        
    Returns:
        Number of tickets inserted
    """
    logger.info(f"Generating {total_tickets} predictions for draw date: {draw_date}")
    logger.info(f"   Using historical data BEFORE {draw_date} to prevent data leakage")
    
    # Generate tickets using StrategyManager
    # CRITICAL: Pass max_date to prevent data leakage
    manager = StrategyManager(max_date=draw_date)
    tickets = manager.generate_balanced_tickets(total=total_tickets)
    
    logger.info(f"✅ {len(tickets)} tickets generated by StrategyManager")
    
    # Insert tickets into database
    with get_db_connection() as conn:
        cursor = conn.cursor()
        
        inserted = 0
        for ticket in tickets:
            try:
                cursor.execute("""
                    INSERT INTO generated_tickets (
                        draw_date, strategy_used, n1, n2, n3, n4, n5, powerball, confidence_score
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    draw_date,
                    ticket['strategy'],  # This comes from StrategyManager
                    ticket['white_balls'][0],
                    ticket['white_balls'][1],
                    ticket['white_balls'][2],
                    ticket['white_balls'][3],
                    ticket['white_balls'][4],
                    ticket['powerball'],
                    ticket.get('confidence', 0.5)
                ))
                inserted += 1
            except Exception as e:
                logger.error(f"Error inserting ticket: {e}")
                continue
        
        conn.commit()
        logger.success(f"✅ Inserted {inserted}/{len(tickets)} tickets for {draw_date}")
        
    return inserted


def main():
    """Main execution function."""
    parser = argparse.ArgumentParser(
        description='Generate historical predictions for past Powerball draws'
    )
    parser.add_argument(
        '--from-date',
        type=str,
        default='2025-11-18',
        help='Generate predictions for draws on or before this date (YYYY-MM-DD)'
    )
    parser.add_argument(
        '--count',
        type=int,
        default=10,
        help='Number of past draws to generate predictions for'
    )
    parser.add_argument(
        '--tickets-per-draw',
        type=int,
        default=500,
        help='Number of tickets to generate per draw'
    )
    parser.add_argument(
        '--evaluate',
        action='store_true',
        help='Evaluate predictions after generation'
    )
    
    args = parser.parse_args()
    
    logger.info("=" * 60)
    logger.info("HISTORICAL PREDICTIONS GENERATOR")
    logger.info("=" * 60)
    logger.info(f"From date: {args.from_date}")
    logger.info(f"Number of draws: {args.count}")
    logger.info(f"Tickets per draw: {args.tickets_per_draw}")
    logger.info("=" * 60)
    
    # Get historical draw dates
    draw_dates = get_historical_draw_dates(args.from_date, args.count)
    
    if not draw_dates:
        logger.error(f"No draw dates found on or before {args.from_date}")
        return 1
    
    logger.info(f"Found {len(draw_dates)} historical draws:")
    logger.info(f"Processing in CHRONOLOGICAL order (oldest → newest) for adaptive learning:")
    for i, date in enumerate(draw_dates, 1):
        logger.info(f"  {i}. {date}")
    
    # Generate predictions for each date (oldest → newest)
    # This order ensures adaptive learning updates weights progressively
    total_inserted = 0
    for idx, draw_date in enumerate(draw_dates, 1):
        logger.info(f"\n[{idx}/{len(draw_dates)}] Processing draw: {draw_date}")
        try:
            inserted = generate_predictions_for_date(draw_date, args.tickets_per_draw)
            total_inserted += inserted
        except Exception as e:
            logger.error(f"Error generating predictions for {draw_date}: {e}")
            continue
    
    logger.success("=" * 60)
    logger.success(f"COMPLETED: {total_inserted} total tickets generated")
    logger.success(f"Average: {total_inserted / len(draw_dates):.0f} tickets per draw")
    logger.success("=" * 60)
    
    # Evaluate if requested
    if args.evaluate:
        logger.info("Evaluating generated predictions...")
        try:
            from src.prediction_evaluator import PredictionEvaluator
            evaluator = PredictionEvaluator()
            
            for draw_date in draw_dates:
                logger.info(f"Evaluating predictions for {draw_date}...")
                result = evaluator.evaluate_predictions_for_date(draw_date)
                logger.info(f"  Results: {result.get('total_predictions', 0)} predictions, "
                           f"{result.get('total_wins', 0)} wins")
            
            logger.success("✅ Evaluation completed for all draws")
        except Exception as e:
            logger.error(f"Error during evaluation: {e}")
    
    return 0


if __name__ == "__main__":
    sys.exit(main())
